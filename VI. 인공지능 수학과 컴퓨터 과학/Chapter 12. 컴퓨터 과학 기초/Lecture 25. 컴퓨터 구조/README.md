# 1. 컴퓨터 구조 개요

## 1. 컴퓨터가 이해하는 정보

- 데이터
    - 숫자, 문자, 이미지, 동영상과 같은 정적인 정보
    - 컴퓨터와 주고받는 정보, 컴퓨터에 저장된 정보 자체
    - 명령어에 종속적인 정보
- 명령어
    - 데이터를 활용하는 정보

## 2. 컴퓨터의 핵심 부품

### CPU

- 정보를 읽어 들이고, 해석하고, 실행하는 부품
- 산술논리연산장치(ALU)
    - 연산을 수행할 회로로 구성되어 있는 일종의 계산기
    - CPU가 처리할 명령어를 실질적으로 연산하는 요소
- 제어장치(CU)
    - 명령어를 해석해 제어 신호라는 전기 신호를 내보내는 장치
- 레지스터
    - CPU 내부의 작은 임시 저장장치
    - 데이터와 명령어를 처리하는 과정의 중간값 저장

### 메모리와 캐시 메모리

- 메인 메모리 역할 : RAM(일반적으로 메모리로 지칭), ROM
- 현재 실행 중인 프로그램을 구성하는 데이터와 명령어를 저장하는 부품
- 주소
    - 메모리 속 데이터와 명령어가 중구난방으로 저장되어 있지 않아야 함
    - CPU가 원하는 정보로 접근하기 위해 사용
- 휘발성
    - 전원이 공급되지 않을 때 저장하고 있는 정보가 지워지는 특성
- 캐시 메모리
    - CPU와 메모리 사이에 반드시 하나 이상의 캐시 메모리 존재
    - CPU가 조금이라도 더 빨리 메모리에 저장된 값에 접근하기 위해 사용하는 저장장치

### 보조기억장치

- 전원이 꺼져도 저장된 정보가 사라지지 않는 비휘발성 저장장치
- CD-ROM, DVD, 하드 디스크 드라이브, 플래시 메모리, 플로피 디스크
- 보관할 프로그램 저장
- CPU가 보조기억장치에 저장된 프로그램을 곧장 가져와 실행 불가
- 프로그램 실행을 위해 보조기억장치에서 보관하고 있는 프로그램을 메모리로 복사 필요

### 입출력장치

- 컴퓨터 외부에 연결되어 컴퓨터 내부와 정보를 교환하는 장치
- 입력장치 : 컴퓨터에 어떠한 입력을 할 때 사용하는 장치, 마우스, 키보드, 마이크 등
- 출력장치 : 컴퓨터의 정보를 받기 위해 사용하는 장치, 스피커, 모니터, 프린트 등

### 메인보드와 버스

- 메인 보드 : 부품들을 고정하고 연결하는 기판
- 버스 : 각 컴퓨터 부품들이 정보를 주고받는 통로
- 시스템 버스 : 핵심 부품들을 연결

## 3. 저장장치의 계층 구조

- CPU와 가까운 저장장치는 빠르고, 멀리 있는 저장장치는 느림
- 속도가 빠른 저장장치는 용량이 작고, 가격이 비쌈
- CPU → 레지스터 → 캐시 메모리 → 메모리 → 보조기억장치

# 2. 컴퓨터가 이해하는 정보

## 1. 개요

### 프로그램 관점에서의 정보 단위

- 비트 : 0과 1을 나타내는 가장 작은 정보의 단위
- N비트 → $2^N$개 정보 표현 가능
- 바이트 : 8비트를 묶은 단위, 256개 정보 표현
- 킬로바이트, 메가바이트, 기가바이트, 테라바이트 : 이전 단위 100개를 묶은 단위

### CPU 관점에서의 정보 단위

- 워드 : CPU가 한 번에 처리할 수 있는 데이터의 크기
- 현대 컴퓨터의 워드 크기 : 32비트, 64비트

## 2. 데이터 - 0과 1로 숫자 표현하기

### 진법 표현법

- 2진법 : 0과 1로 모든 수 표현
- 10진법 : 0~9까지의 10개의 숫자만으로 모든 수 표현
- 16진법 : 숫자 15를 넘어가는 시점에 자리올림, 0~9, A~F로 표현

### 소수 표현

- 부동 소수점
    - 컴퓨터 내부에서 소수점을 나타내기 위한 방법
    - 소수점이 고정되어 있지 않은 소수 표현 방식
- 2진수 소수 표현 : $m \times 2^n$
- IEEE 754
    - 32비트 : 1비트 부호 + 8비트 지수 + 23비트 가수
    - 64비트 : 1비트 부호 + 11비트 지수 + 52비트 가수
    - 가수의 정수부 표현 : 1로 통일된 정규화한 수
    - 지수에 해당하는 값과 소수 부분만 저장
    - 바이어스 : 지수 저장 시 사용, $2^{k - 1} - 1$
- 10진수 소수를 2진수로 표현할 때, 10진수 소수와 2진수 소수의 표현이 딱 맞아떨어지지 않을 수 있음

## 3. 데이터 - 0과 1로 문자 표현하기

- 문자 집합 : 컴퓨터가 이해할 수 있는 문자들의 집합
- 문자 인코딩 : 문자 집합에 속한 문자를 컴퓨터가 이해하는 0과 1로 이루어진 문자 코드로 변환하는 과정
- 문자 디코딩 : 0과 1로 표현된 문자를 사람이 이해하는 문자로 변환하는 과정
- 아스키 코드
    - 초창기 컴퓨터에서 사용하던 문자 집합 중 하나
    - 8비트 : 1비트 오류 검출 패리티 비트 + 7비트 문자 표현
- EUC-KR
    - KS X 1001, KS X 1003의 문자 집합 기반의 인코딩 방식
    - 아스키 문자 1바이트, 하나의 한글 글자 2바이트 크기 부여
- 유니코드
    - 언어, 특수문자, 화살표, 이모티콘까지 코드로 표현할 수 있는 통일된 문자 집합
    - 대부분의 언어 지원
    - 글자에 부여된 값 자체를 인코딩된 값으로 삼지 않고 다양한 방법으로 인코딩
    - UTF-8, UTF-16, UTF-32 : 유니코드 문자에 부여된 값을 인코딩하는 방식
    - UTF-8, UTF-16 가변 길이 인코딩, UTF-32 고정 길이 인코딩
- base64
    - 문자뿐만 아니라 이진 데이터까지 변환할 수 있는 인코딩 방식
    - 단순 문자 이외의 데이터까지 모두 아스키 문자 형태로 표현 가능
    - 변환할 데이터를 6비트씩 나누어 하나의 문자로 변환 → 4개씩 한 번에 변환
    - 6비트씩 나누어 떨어지지 않는 경우 0으로 채워지는 패딩 발생

## 4. 명령어

### 명령어 개요

- 수행할 대상 : 수행할 동작에 사용될 데이터 자체, 동작에 사용될 데이터가 저장된 위치
- 연산 코드 : 명령어가 수행할 동작
- 오퍼랜드 : 동작에 사용될 데이터, 동작에 사용될 데이터가 저장된 위치
- 하나의 명령어 : 연산 코드(연산자) + 0개 이상의 오퍼랜드(피연산자)로 구성
- 주소 필드(오퍼랜드 필드) : 연산 코드에 사용될 데이터가 저장된 위치 명시
- 오퍼랜드에 메모리 주소 명시 시 명령어를 실행하기 위한 메모리 접근 더 필요

### 연산 코드

- 데이터 전송
    - MOVE : 데이터를 옮겨라
    - STORE : 메모리에 저장해라
    - LOAD(FETCH) : 데이터를 메모리에서 CPU로 가져와라
    - PUSH : 데이터를 스택에 저장해라
    - POP : 스택의 최상단 데이터를 가져와라
- 산술/논리 연산
    - ADD/SUBTRACT/MULTIPLY/DIVIDE : 덧셈/뺼셈/곱셈/나눗셈을 수행하라
    - INCREMENT/DECREMENT : 오퍼랜드에 1을 더해라/오퍼랜드에서 1을 빼라
    - ADD/OR/NOT : AND/OR/NOT 연산을 수행해라
    - COMPARE : 두 개의 숫자, TRUE/FALSE 값을 비교해라
- 제어 흐름 변경
    - JUMP : 특정 주소로 실행 순서를 옮겨라
    - CONDITIONAL JUMP : 조건에 부합할 경우 특정 주소로 실행 순서를 옮겨라
    - HALT : 프로그램의 실행을 멈춰라
    - CALL : 되돌아올 주소를 저장한 채 특정 주소로 실행 순서를 옮겨라
    - RETURN : CALL을 호출할 때 저장했던 주소로 돌아가라
- 입출력 제어
    - READ(INPUT) : 특정 입출력장치로부터 데이터를 읽어라
    - WRITE(OUTPUT) : 특정 입출력장치로 데이터를 써라
    - START IO : 입출력장치를 시작해라
    - TEST IO : 입출력장치의 현재 상태를 확인해라

### 기계어와 어셈블리어

- 기계어 : CPU가 이해할 수 있도록 0과 1로 표현된 정보를 있는 그대로 표현한 언어
- 어셈블리어 : 0과 1로 표현된 기계어를 읽기 편한 형태로 단순 번역한 언어

### 명령어 사이클

- 명령어 사이클 : CPU가 명령어를 처리하는 과정에서 프로그램 속 각각의 명령어들은 일정한 주기를 반복하며 실행
    - 인출 사이클 : 메모리에 있는 명령어를 CPU로 가지고 오는 단계
    - 실행 사이클 : CPU로 가져온 명령어를 실행하는 단계
    - 간접 사이클 : 명령어를 실행하기 위해 한 번 더 메모리에 접근하는 단계
- 인터럽트 사이클 : 인터럽트 처리

# 3. CPU

## 1. 레지스터

### 프로그램 카운터(PC, 명령어 포인터(IP))

- 메모리에서 다음으로 읽어 들일 명령어의 주소 저장
- 일반적으로 PC는 1씩 증가 → 다음으로 읽어 들일 메모리 주소가 1씩 증가
- 조건문이나 리턴문 실행 → 실행 흐름이 순차적이지 않음 → PC값이 임의의 위치로 변경

### 명령어 레지스터(IR)

- 메모리에서 방금 읽어 들인 명령어를 저장하는 레지스터
- CPU 내 제어장치는 IR 속 명령어를 해석한 뒤 ALU에 연산을 시키거나 다른 부품 작동

### 범용 레지스터

- 다양하고 일반적인 상황에서 자유롭게 사용할 수 있는 레지스터
- 데이터, 명령어, 주소 모두 저장 가능

### 플래그 레지스터

- 연산의 결과 혹은 CPU 상태에 대한 부가 정보인 플래그 값을 저장하는 레지스터
- 플래그 : CPU가 명령어를 처리하는 과정에서 반드시 참조해야 할 상태 정보를 의미하는 비트
    - 부호 플래그 : 연산 결과의 부호, 1일 경우 음수 0일 경우 양수
    - 제로 플래그 : 연산 결과가 0인지의 여부, 1일 경우 0 0일 경우 0이 아님
    - 캐리 플래그 : 연산 결과에 올림수나 빌림수가 발생했는지의 여부, 1일 경우 발생 0일 경우 미발생
    - 오버플로우 플래그 : 오버플로우가 발생했는지의 여부, 1일 경우 발생 0일 경우 미발생
    - 인터럽트 플래그 : 인터럽트가 가능한지의 여부, 1일 경우 가능 0일 경우 불가능
    - 슈퍼바이저 플래그 : 커널 모드로 실행 중인지, 사용자 모드로 실행 중인지의 여부, 1일 경우 커널 모드 0일 경우 사용자 모드

### 스택 포인터

- 스택 영역 : 암묵적으로 스택처럼 사용하자고 약속된 메모리 영역
- 메모리 내 스택 영역의 최상단 스택 데이터 위치를 가리키는 특별한 레지스터
- 마지막으로 스택에 저장된 데이터의 위치를 가리키는 레지스터
- 스택이 채워진 정도를 나타내는 레지스터

## 2. 인터럽트

### 개요

- CPU의 작업을 방해하는 신호
- 동기 인터럽트(예외)
    - CPU에 의해 발생하는 인터럽트
    - 예외적인 상황을 마주쳤을 때 발생
- 비동기 인터럽트(인터럽트)
    - 입출력장치에 의해 발생
    - 알림의 역할

### 하드웨어 인터럽트

- 효율적으로 명령어를 처리하기 위해 사용
- 작업이 끝나기를 기다릴 필요 없이 다른 작업 처리 가능
- CPU 사이클 낭비 최소화 및 다른 일 수행 가능
- CPU가 하드웨어 인터럽트를 처리하는 순서
    - 입출력장치는 CPU에 인터럽트 요청 신호 보냄
    - CPU는 실행 사이클이 끝나고 명령어를 인출하기 전에 항상 인터럽트 여부 확인
    - CPU는 인터럽트 요청 확인 후 인터럽트 플래그를 통해 현재 인터럽트를 받아들일 수 있는지 여부 확인
    - 인터럽트를 받아들일 수 있다면 CPU가 지금까지의 작업 백업
    - CPU는 인터럽트 벡터를 참조하여 인터럽트 서비스 루틴 실행
    - 인터럽트 서비스 루틴 실행 종료 후 백업해 둔 작업 복구 후 실행 재개
- 인터럽트 요청 신호 : 인터럽트하기 전에 CPU에게 인터럽트의 가능 여부를 확인하는 것
- 인터럽트 플래그 : 하드웨어 인터럽트를 받아들일지, 무시할지를 결정하는 플래그
- 막을 수 있는 인터럽트
- 막을 수 없는 인터럽트 : 가장 우선순위가 높은, 가장 먼저 처리해야 하는 인터럽트, 정전/하드웨어 고장
- 인터럽트 서비스 루틴(ISR, 인터럽트 핸들러) : 어떤 인터럽트가 발생했을 때 해당 인터럽트를 어떻게 처리하고 작동해야 할지에 대한 정보로 이루어진 프로그램
- 인터럽트 벡터 : 인터럽트 서비스 루틴을 식별하기 위한 정보

### 예외

- 폴트 : 예외를 처리한 직후에 예외가 발생한 명령어부터 실행을 재개하는 예외
- 트랩 : 예외를 처리한 직후에 예외가 발생한 명령어의 다음 명령어부터 실행을 재개하는 예외
- 중단 : CPU가 실행 중인 프로그램을 강제로 중단시킬 수밖에 없는 심각한 오류를 발견했을 때 발생하는 예외
- 소프트웨어 인터럽트 : 시스템 콜이 발생했을 때 발생하는 예외

## 3. CPU 성능 향상을 위한 설계

### CPU 클럭 속도

- 클럭 : 컴퓨터의 부품을 일사불란하게 움직일 수 있게 하는 시간의 단위
- 클럭 속도 : 클럭이 1초에 몇 번 반복되는지를 나타냄, 헤르츠(Hz) 단위

### 멀티코어와 멀티스레드

- 코어 : CPU 내에서 명령어를 읽어 들이고, 해석하고, 실행하는 부품
- 멀티코어 CPU(멀티코어 프로세서) : 여러 개의 코어를 포함하고 있는 CPU
- 스레드 : 실행 흐름의 단위
- 하드웨어 스레드(논리 프로세서) : 하나의 코어가 동시에 처리하는 명령어의 단위
- 멀티스레드 프로세서(멀티스레드 CPU) : 하나의 코어로 여러 명령어를 동시에 처리하는 CPU
- 소프트웨어 스레드 : 하나의 프로그램에서 독립적으로 실행되는 단위
- 병렬성 : 작업을 물리적으로 동시에 처리하는 성질, 하드웨어 스레드
- 동시성 : 동시에 작업을 처리하는 것처럼 보이는 성질, 소프트웨어 스레드

## 4. 파이프라이닝을 통한 명령어 병렬 처리

- 명령어 병렬 처리 기법(ILP) : 여러 명령어를 동시에 처리하여 CPU를 한시도 쉬지 않고 작동시킴으로써 CPU의 성능을 높이는 기법
- 명령어가 처리되는 과정
    - 명령어 인출 → 명령어 해석 → 명령어 실행 → 결과 저장
    - 같은 단계가 겹치지만 않으면 CPU가 각각의 단계를 동시에 실행 가능
- 명령어 파이프라이닝 : 명령어들을 명령어 파이프라인에 넣고 동시에 처리하는 기법
- CISC
    - 다채로운 기능을 지원하는 복잡한 명령어들로 구성된 명령어 집합
    - 적은 수의 명령어로도 프로그램 실행 가능
    - 명령어의 크기 및 실행되기까지의 시간이 일정하지 않음
    - 하나의 명령어 실행에 여러 클럭 주기가 필요
    - 파이프라이닝에 비효율적
    - x86, x86-64 CPU
- RISC
    - CISC에 비해 활용 가능한 명령어 종류 적음
    - 짧고 규격화된 명령어, 되도록이면 1클럭 내외로 실행되는 명령어 지향
    - 규격화된 크기, 하나의 명령어가 1클럭 내외로 실행
    - 파이프라이닝에 최적화
    - M1 CPU
- 파이프라인 위험 : 파이프라이닝이 실패하여 성능 향상이 이루어지지 않는 상황
    - 데이터 위험 : 명령어 간의 데이터 의존성에 의해 발생
    - 제어 위험 : 프로그램 카운터의 갑작스러운 변화에 의해 발생
    - 구조적 위험(자원 위험) : 명령어들을 겹쳐 실행하는 과정에서 서로 다른 명령어가 동시에 ALU, 레지스터 등 같은 CPU 부품을 사용하려고 할 때 발생

# 4. 메모리

## 1. RAM

### 개요

- 휘발성 저장장치, 임의 접근 메모리
- 임의 접근(직접 접근) : 저장된 요소에 순차적으로 접근할 필요 없이 임의의 위치에 곧장 접근 가능한 방식
- 순차 접근 : 특정 위치에 저장된 요소에 접근하기 위해 처음부터 순차적으로 접근하는 방식

### DRAM

- 시간이 지나면 저장된 데이터가 점차 사라지는 RAM
- 데이터의 소멸을 막기 위해 일정 주기로 데이터 재활성화 필요
- 소비 전력이 낮고, 저렴하며, 집적도가 높음 → 대용량으로 설계 용이

### SRAM

- 시간이 지나도 저장된 데이터가 사라지지 않는 RAM
- 소비 전력이 크고 가격이 비싸며 집적도가 낮음 → 속도가 빨라야 하는 저장장치에 사용

### SDRAM

- 클럭 신호와 동기화된 보다 발전한 형태의 DRAM
- 클럭에 맞춰 작동하며 CPU와 정보를 주고받을 수 있는 DRAM

### DDR SDRAM

- 대역폭을 넓혀 속도를 빠르게 만든 SDRAM
- 대역폭 : 데이터를 주고받을 길의 너비
- SDR SDRAM < DDR SDRAM < DDR2 SDRAM < DDR3 SDRAM < DDR4 SDRAM

## 2. 메모리에 바이트를 밀어 넣는 순서 - 빅 엔디안과 리틀 엔디안

- 빅 엔디안
    - 낮은 번지의 주소에 상위 바이트부터 저장하는 방식
    - 숫자의 크기에 가장 큰 영향을 미치는 유효 숫자인 MSB가 있는 바이트부터 저장
    - 일상적으로 숫자 체계를 읽고 쓰는 순서와 동일
    - 메모리 값을 직접 읽거나 디버깅에 편리
- 리틀 엔디안
    - 낮은 번지의 주소에 하위 바이트부터 저장하는 방식
    - 숫자의 크기에 가장 적은 영향을 미치는 유효 숫자인 LSB가 있는 바이트부터 저장
    - 메모리 값을 직접 읽고 쓰기는 불편
    - 수치 계산 편리

## 3. 캐시 메모리

### 개요

- 캐시 메모리 : CPU의 연산 속도와 메모리 접근 속도의 차이를 줄이기 위해 탄생한 저장장치
- CPU와 메모리 사이에 위치한 SRAM 기반의 저장장치
- L1 캐시 : 코어와 가장 가까운 캐시 메모리, 코어 내부
- L2 캐시 : 그 다음으로 가까운 캐시 메모리, 코어 내부
- L3 캐시 : 제일 멀리 떨어져 있는 캐시 메모리, 코어 외부
- 캐시 메모리 크기 : L1 < L2 < L3
- 캐시 메모리 속도 : L3 < L2 < L1
- L1 → L2 → L3 순으로 데이터 탐색
- 분리형 캐시 : 명령어만을 저장하는 L1I 캐시 + 데이터만을 저장하는 L1D 캐시

### 캐시 히트와 캐시 미스

- CPU가 사용할 법한 것 저장
- 캐시 히트 : 캐시 메모리가 예측하여 저장한 데이터 CPU에 의해 실제로 사용되는 경우
- 캐시 미스 : 자주 사용될 것으로 예측하여 캐시 메모리에 저장했지만 틀린 예측으로 인해 CPU가 메모리로부터 필요한 데이터를 직접 가져와야 하는 경우
- 캐시 적중률 : 캐시가 히트되는 비율, 캐시 히트 횟수 / (캐시 히트 횟수 + 캐시 미스 횟수)

### 참조 지역성의 원리

- CPU가 메모리에 접근할 때 보이는 다음과 같은 주된 경향에 따라 데이터 결정
    - 시간 지역성 : 최근에 접근했던 메모리 공간에 다시 접근하려는 경향, 변수
    - 공간 지역성 : 접근한 메모리 공간의 근처에 접근하려는 경향, 배열

### 캐시 메모리의 쓰기 정책과 일관성

- 캐시 메모리에 새롭게 쓰여진 데이터와 메모리 상의 데이터 일관성 유지 필요
- 즉시 쓰기
    - 캐시 메모리와 메모리 동시에 쓰는 방법
    - 메모리를 항상 최신 상태로 유지하여 캐시 메모리와 메모리 간의 일관성이 깨지는 상황 방지 가능
    - 데이터를 쓸 때마다 메모리를 참조 → 버스의 사용 시간과 쓰기 시간 늘어남
- 지연 쓰기
    - 캐시 메모리에만 값을 써 두었다가 추후 수정된 데이터를 한 번에 메모리에 반영하는 방법
    - 메모리 접근 횟수를 줄일 수 있음 → 즉시 쓰기 방식에 비해 속도 빠름
    - 메모리와 캐시 메모리 간의 일관성 깨질 수 있음
    - 다른 코어가 사용하는 캐시 메모리와의 불일치도 발생 가능