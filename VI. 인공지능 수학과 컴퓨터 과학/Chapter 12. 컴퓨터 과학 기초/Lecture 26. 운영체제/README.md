# 1. 운영체제 개요

## 1. 운영체제의 역할

### 개요

- 커널 : 운영체제의 핵심 기능을 담당하는 부분
- 자원 : 프로그램 실행에 마땅히 필요한 요소

### CPU 관리 : CPU 스케줄링

- 실행 중인 모든 프로그램들이 공정하고 합리적으로 CPU를 할당받도록 CPU의 할당 순서와 사용 시간 결정

### 메모리 관리 : 가상 메모리

- 실제 물리적인 메모리 크기보다 더 큰 메모리를 이용할 수 있도록 하는 기술

### 파일/디렉터리 관리 : 파일 시스템

- 보조기억장치 내의 정보를 파일 및 폴더 단위로 접근/관리할 수 있도록 만드는 운영체제 내부 프로그램

### 프로세스 및 스레드 관리

- 프로세스 : 실행 중인 프로그램
- 스레드 : 프로세스를 이루는 실행 단위
- 프로세스와 스레드가 올바르게 처리되도록 실행의 순서를 제어하고 자원을 적절하게 배분

## 2. 시스템 콜과 이중 모드

- 커널 영역 : 사용자 프로그램이 아닌 운영체제가 적재되는 메모리 공간
- 사용자 영역 : 운영체제가 적재되는 커널 영역 외에 사용자 응용 프로그램이 적재되는 공간
- 시스템 콜 : 운영체제의 서비스를 제공 받기 위한 수단, 호출 가능한 함수 형태
- 부모 프로세스 : 새 프로세스를 생성한 프로세스
- 자식 프로세스 : 부모 프로세스에 의해 생성된 프로세스
- 소프트웨어 인터럽트 : 명령어에 의해 발생하는 인터럽트, 자원에 접근하는 입출력 명령어
- 사용자 영역 실행 중 시스템 콜 호출 → 현재 수행 중인 작업 백업 → 커널 영역 내의 인터럽트를 처리하기 위한 코드 실행 → 다시 사용자 영역 코드 실행
- 사용자 모드
    - 사용자 영역에 적재된 코드를 실행할 때의 실행 모드
    - 운영체제 서비스를 제공받을 수 없는 실행 모드
- 커널 모드
    - 커널 영역에 적재된 코드를 실행할 때의 실행 모드
    - 운영체제 서비스를 제공받을 수 있는 실행 모드
- 이중 모드 : 사용자 모드, 커널 모드 2개의 모드로 구분하여 실행하는 것

# 2. 프로세스와 스레드

## 1. 프로세스

### 개요

- 포그라운드 프로세스 : 사용자가 보는 공간에서 사용자와 상호작용하며 실행
- 백그라운드 프로세스 : 사용자가 보지 못하는 곳에서 실행
- 데몬(서비스) : 백그라운드 프로세스 중 사용자와 별다른 상호작용 없이 주어진 작업만 수행하는 특별한 백그라운드 프로세스
- 코드 영역(텍스트 영역)
    - 실행 가능한 명령어가 저장되는 공간
    - CPU가 읽고 실행할 명령어 보관 → 읽기 전용 공간
- 데이터 영역
    - 프로그램이 실행되는 동안 유지할 데이터가 저장되는 공간
    - 정적 변수, 전역 변수 → 초기값이 있는 데이터
- BSS 영역
    - 프로그램을 사용하는 동안 유지할 데이터 중 초기값이 없는 데이터가 저장되는 공간
- 힙 영역
    - 프로그램을 만드는 사용자가 직접 할당 가능한 저장 공간
    - 프로그램 실행 도중 비교적 자유롭게 할당하여 사용 가능한 메모리 공간
    - 메모리 누수 : 메모리 공간 미반환 시 할당한 공간이 계속 메모리 내에 남아 메모리를 낭비하는 것
- 스택 영역
    - 데이터 영역에 담기는 값과는 달리 일시적으로 사용할 값들이 저장되는 공간
    - 매개변수, 지역 변수, 함수 복귀 주소
    - 스택 트레이스 형태의 함수 호출 정보 저장 가능
    - 스택 트레이스 : 특정 시점에 스택 영역에 저장된 함수 호출 정보

### PCB와 문맥 교환

- 프로세스 제어 블록(PCB)
    - 프로세스와 관련한 다양한 정보를 내포하는 구조체의 일종
    - 새로운 프로세스가 메모리에 적재됐을 때 커널 영역에 만들어지고, 프로세스의 실행이 끝나면 폐기
- PCB에 담기는 정보
    - 프로세스 ID(PID) : 프로세스 식별 번호
    - 프로세스가 실행 과정에서 사용한 레지스터 값
    - 프로세스 상태 : 프로세스가 현재 어떤 상태인지를 나타냄
    - CPU 스케줄링 정보 : 프로세스가 언제, 어떤 순서로 CPU를 할당받을지 나타냄
    - 메모리 관련 정보 : 프로세스의 메모리상 적재 위치 확인
    - 프로세스가 사용한 파일 및 입출력장치 관련 정보
- 프로세스 테이블 : 실행 중인 PCB의 모음
- 프로세스 실행 : 운영체제에 의해 CPU의 자원을 할당받음
- 타이머 인터럽트(타임아웃 인터럽트) : 시간이 끝났음을 알리는 인터럽트
- 프로세스는 자신의 차례가 되면 정해진 시간만큼 CPU 사용 → 타이머 인터럽트 발생 시 자신의 차례 양보 후 다음 차례가 올 때까지 대기
- 문맥 : 백업 대상이 되는 중간 정보, 프로세스의 수행을 재개하기 위해 기억해야 할 정보
- 프로세스가 CPU 사용 시간이 다 되거나 인터럽트 발생 → 운영체제는 해당 프로세스의 PCB에 문맥 백업 → 실행할 프로세스의 문맥 복구
- 문맥 교환 : 기존 프로세스의 문맥을 PCB에 백업하고, PCB에서 문맥을 복구하여 새로운 프로세스를 실행하는 것
- 프로세스 간 잦은 문맥 교환 → 캐시 미스 발생 가능성 증가 → 큰 오버헤드 발생

### 프로세스의 상태

- 생성 상태(new)
    - 프로세스를 생성 중인 상태
    - 메모리에 적재되어 PCB를 할당받은 상태
    - 실행 준비가 완료된 프로세스는 준비 상태가 되어 CPU 할당 대기
- 준비 상태(ready)
    - CPU를 할당받아 실행할 수 있지만, 자신의 차례가 아니라 기다리고 있는 상태
    - 준비 상태인 프로세스가 CPU를 할당받으면 실행 상태가 됨
    - 디스패치 : 준비 상태인 프로세스가 실행 상태로 전환되는 것
- 실행 상태(running)
    - CPU를 할당받아 실행 중인 상태
    - 일정 시간 동안만 CPU를 사용할 수 있음
    - 타이머 인터럽트 발생 → 프로세스가 할당된 시간 모두 사용 → 준비 상태 전환
    - 실행 도중 입출력장치 사용 → 입출력장치 작업 종료까지 대기 → 대기 상태 전환
- 대기 상태(blocked)
    - 곧장 실행이 불가능한 조건에 놓이는 경우
    - 입출력 작업 요청, 바로 확보할 수 없는 자원 요청
    - 실행 가능한 상태 → 준비 상태 → CPU 할당 대기
- 종료 상태(terminated)
    - 프로세스가 종료된 상태
    - 운영체제는 PCB와 프로세스가 사용한 메모리 정리
- 블로킹 입출력 : 프로세스가 실행 도중 입출력 작업 수행 시 대기 상태로 전환 후, 입출력 작업 완료 시 준비 상태가 되어 실행 재개
- 논블로킹 입출력 : 입출력장치에게 입출력 작업을 맡긴 뒤, 곧바로 이어질 명령어 실행하는 것

## 2. 멀티프로세스와 멀티스레드

- 멀티프로세스
    - 동시에 여러 프로세스가 실행되는 것
    - 자원을 공우하지 않고, 독립적으로 실행
    - 한 프로세스에 문제가 생겨도 다른 프로세스에는 지장이 없거나 적음
- 멀티스레드
    - 프로세스를 동시에 실행하는 여러 스레드
    - 프로세스 자원 공유
    - 한 스레드에 생긴 문제가 프로세스 전체 문제가 될 수 있음

## 3. 프로세스 간 통신

### 개요

- 프로세스 간 통신(IPC) : 프로세스 간에도 자원을 공유하고 데이터를 주고 받을 수 있는 방법
    - 공유 메모리 : 데이터를 주고받는 프로세스가 공통적으로 사용할 메모리 영역을 두는 방식
    - 메시지 전달 : 프로세스 간에 주고받을 데이터를 메시지의 형태로 주고받는 방식

### 공유 메모리

- 프로세스 간에 공유하는 메모리 영역을 토대로 데이터를 주고받는 통신 방식
- 특정 프로세스가 다른 프로세스의 메모리 공간을 임의로 수정할 수 없음
- 공유 메모리 할당 → 프로세스가 해당 메모리 공간 공유 및 읽고 쓰기 가능
- 통신을 주고받는 각 프로세스가 마치 자신의 메모리 영역을 읽고 쓰는 것처럼 통신

### 메시지 전달

- 프로세스 간에 주고받을 데이터가 커널을 거쳐 송수신되는 통신 방식
- 메시지를 보내는 수단과 받는 수단이 명확하게 구분
- 주고받는 데이터가 커널을 통해 송수신 → 공유 메모리 기반 IPC보다 통신 속도 느림
- 파이프 : 단방향 프로세스 간 통신 도구
    - 익명 파이프 : 단방향 통신 수단인 전통적인 파이트
    - 지명 파이프 : 익명 파이프를 확장한 파이프, 양방향 통신 지원
- 시그널 : 프로세스에게 특정 이벤트가 발생했음을 알리는 비동기적인 신호
- 시그널 발생 → 하던 일 잠시 중단 → 시그널 처리를 위한 시그널 핸들러 실행 → 실행 재개
- 원격 프로시저 호출(RPC) : 원격 코드를 실행하는 IPC 기술
- 네트워크 소켓을 통한 IPC 수행

# 3. 동기화와 교착 상태

## 1. 개요

- 공유 자원 : 프로세스 혹은 스레드가 공유하는 자원
- 임계 구역 : 공유 자원에 접근하는 코드 중 동시에 실행했을 때 문제가 발생할 수 있는 코드
- 레이스 컨디션 : 프로세스 혹은 스레드가 동시에 임계 구역의 코드를 실행하여 문제가 발생하는 상황
- 동기화 : 아래 2가지 조건을 준수하며 실행하는 것
    - 실행 순서 제어 : 프로세스 및 스레드를 올바른 순서로 실행하기
    - 상호 배제 : 동시에 접근해서는 안 되는 자원에 하나의 프로세스 및 스레드만 접근하기

## 2. 동기화 기법

### 뮤텍스 락

- 동시에 접근해서는 안 되는 자원에 동시 접근이 불가능하도록 상호 배제를 보장하는 동기화 도구
- 임계 구역에 접근하고자 하면 반드시 락을 획득해야 하고, 임계 구역에서의 작업이 끝났다면 락을 해제해야 함
- acquire() 함수 : 락을 획득하기 위한 함수
- release() 함수 : 획득한 락을 해제하기 위한 함수

### 세마포

- 뮤텍스 락과 비슷하지만 조금 더 일반화된 방식의 동기화 도구
- 공유 자원이 여러 개 있는 상황에서도 동기화 가능
- 변수 S : 사용 가능한 공유 자원의 개수를 나타내는 변수
- wait() 함수 : 임계 구역 진입 전 호출하는 함수
- signal() 함수 : 임계 구역 진입 후 호출하는 함수
- 이진 세마포 : S가 0과 1의 값을 가지는 세마포, 뮤텍스 락과 유사하게 동작
- 카운팅 세마포 : 공유 자원이 여러 개 존재하는 경우에 사용할 수 있는 세마포

### 조건 변수와 모니터

- 조건 변수
    - 실행 순서 제어를 위한 동기화 도구
    - 특정 조건 하에 프로세스를 실행/일시 중단함으로써 프로세스나 스레드의 실행 순서 제어 가능
- wait() 함수 : 호출한 프로세스 및 스레드의 상태를 대기 상태로 전환하는 함수
- signal() 함수 : 일시 중지된 프로세스 및 스레드의 실행을 재개하는 함수
- 모니터
    - 공유 자원과 그 공유 자원을 다루는 함수로 구성된 동기화 도구
    - 상호 배제를 위한 동기화뿐만 아니라 실행 순서 제어를 위한 동기화까지 가능

### 스레드 안전

- 멀티스레드 환경에서 어떤 변수나 함수, 객체에 동시 접근이 이루어져도 실행에 문제가 없는 상태

## 3. 교착 상태

### 교착 상태의 발생 조건

- 일어나지 않을 사건을 기다리며 프로세스의 진행이 멈춰 버리는 현상
- 상호 배제 : 한 프로세스가 사용하는 자원을 다른 프로세스가 사용할 수 없는 상태
- 점유와 대기 : 한 프로세스가 어떤 자원을 할당받은 상태에서 다른 자원 할당받기를 기다리는 것
- 비선점 : 해당 자원을 이용하는 프로세스의 작업이 끝나야만 비로소 자원을 이용할 수 있음
- 원형 대기 : 프로세스와 프로세스가 요청한 자원이 원의 형태를 이루는 것

### 교착 상태의 해결 방법

- 교착 상태 예방
    - 교착 상태를 발생시키는 4가지 필요 조건 중 하나를 충족하지 못하게 하는 방법
    - 한 프로세스에 필요한 자원 몰아주기 → 다음 다른 프로세스에 필요한 자원 몰아주기
    - 할당 가능한 모든 자원에 번호를 매기고 오름차순으로 할당
- 교착 상태 회피
    - 교착 상태가 발생하지 않을 정도로만 조심하면서 자원을 할당하는 방법
    - 교착 상태를 한정된 자원의 무분별한 할당으로 인해 발생하는 문제로 간주
- 교착 상태 검출 후 회복
    - 교착 상태의 발생을 인정하고 처리하는 사후 조치
    - 프로세스가 자원을 요구할 때마다 그때 그때 자원을 할당하고 주기적으로 교착 상태의 발생 여부 검사
    - 교착 상태 검출 → 자원 선점으로 회복, 강제 종료

# 4. CPU 스케줄링

## 1. CPU 스케줄링

### 개요

- CPU 스케줄링 : 운영체제의 CPU 배분 방법
- CPU 스케줄링 알고리즘 : CPU 스케줄링 절차
- CPU 스케줄러 : CPU 스케줄링 알고리즘을 결정하고 수행하는 운영체제 일부분

### 우선순위

- 운영체제는 프로세스별 우선순위를 판단하여 PCB에 명시, 우선순위가 높은 프로세스에 CPU의 자원을 더 빨리, 많이 할당
- CPU 활용률 : 전체 CPU의 가동 시간 중 작업을 처리하는 시간의 비율
- 운영체제는 높은 CPU 활용률을 유지하기 위해 기본적으로 입출력 작업이 많은 프로세스의 우선순위를 높게 유지
- CPU 버스트 : 프로세스가 CPU를 이용하는 작업
- 입출력 버스트 : 입출력장치를 기다리는 작업
- 입출력 집중 프로세스
    - 입출력 작업이 많은 프로세스
    - 비디오 재생, 디스크 백업 작업
    - 실행 상태보다 입출력을 위한 대기 상태에 더 많이 머무름
- CPU 집중 프로세스
    - CPU 작업이 많은 프로세스
    - 복잡한 수학 연산, 그래픽 처리 작업
    - 대기 상태보다 실행 상태에 더 많이 머무름
- 입출력 집중 프로세스를 가능한 빨리 실행시켜 끊임없이 입출력장치를 작동시킨 다음, CPU 집중 프로세스에 집중적으로 CPU를 할당하는 것이 더 합리적

### 스케줄링 큐

- CPU를 이용하고 싶은 프로세스의 PCB와 메모리로 적재되고 싶은 프로세스의 PCB, 특정 입출력장치를 이용하고 싶은 프로세스의 PCB를 큐에 삽입하여 줄 세우는 것
- 준비 큐 : CPU를 이용하고 싶은 프로세스의 PCB가 서는 줄
- 대기 큐 : 대기 상태에 접어든 프로세스의 PCB가 서는 줄
- 운영체제는 큐에 삽입된 순서대로 실행하되, 우선순위가 높은 프로세스부터 먼저 실행

### 선점형 스케줄링과 비선점형 스케줄링

- 선점형 스케줄링
    - 현재 어떤 프로세스가 CPU를 할당받아 사용하고 있더라도 운영체제가 프로세스로부터 CPU 자원을 강제로 빼앗아 다른 프로세스에 할당할 수 있는 스케줄링
    - 타이머 인터럽트 기반 스케줄링
    - 한 프로세스의 CPU 독점을 막고 여러 프로세스에 골고루 CPU 자원을 배분할 수 있음
    - 문맥 교환 과정에서 오버헤드 발생 가능성 높음
- 비선점형 스케줄링
    - 어떤 프로세스가 CPU를 사용하고 있을 때 그 프로세스가 종료되거나 스스로 대기 상태에 접어들기 전까지는 다른 프로세스가 끼어들 수 없는 스케줄링 방식
    - 문맥 교환 횟수가 적기 때문에 상대적으로 오버헤드 발생 가능성 낮음
    - 당장 CPU를 사용해야 하는 프로세스라도 무작정 기다려야 함

## 2. CPU 스케줄링 알고리즘

### 선입 선처리 스케줄링(FCFS)

- 준비 큐에 삽입된 순서대로 먼저 CPU를 요청한 프로세스부터 CPU를 할당하는 스케줄링 방식
- 호위 효과 : 먼저 삽입된 프로세스의 오랜 실행 시간으로 인해 나중에 삽입된 프로세스의 실행이 지연되는 문제

### 최단 작업 우선 스케줄링(SJF)

- 준비 큐에 삽입된 프로세스 중 CPU를 이용하는 시간의 길이가 가장 짧은 프로세스부터 먼저 실행하는 스케줄링 방식
- 기본적으로 비선점형 스케줄링 알고리즘으로 분류, 최소 잔여 시간 우선 스케줄링처럼 선점형으로도 구현 가능

### 라운드 로빈 스케줄링(RR)

- 큐에 삽입된 프로세스들이 삽입된 순서대로 CPU를 이용하되, 정해진 타임 슬라이스만큼만 CPU를 이용하는 선점형 스케줄링
- 타임 슬라이스 : 프로세스가 CPU를 사용하도록 정해진 시간

### 최소 잔여 시간 우선 스케줄링(SRT)

- 프로세스로 하여금 정해진 타임 슬라이스만큼 CPU를 이용하되, 남아 있는 작업시간이 가장 적은 프로세스를 다음으로 CPU를 이용할 프로세스로 선택하는 방식

### 우선순위 스케줄링

- 프로세스에 우선순위를 부여하고, 가장 높은 우선순위를 가진 프로세스부터 실행하는 스케줄링 방식
- 아사 현상 : 우선순위가 낮은 프로세스는 우선순위가 높은 프로세스로 인해 계속해서 실행이 연기되는 것
- 에이징 : 오랫동안 대기한 프로세스의 우선순위를 점차 높이는 방식

### 다단계 큐 스케줄링

- 우선순위별로 여러 개의 준비 큐를 사용하는 스케줄링 방식
- 우선순위가 가장 높은 큐에 있는 프로세스 먼저 처리, 우선순위가 가장 높은 큐가 비어 있을 경우 그 다음으로 우선순위가 높은 큐에 있는 프로세스 처리
- 프로세스들이 큐 사이를 이동할 수 없음 → 아사 현상 발생 가능

### 다단계 피드백 큐 스케줄링

- 다단계 큐 스케줄링과 비슷하게 동작, 프로세스들이 큐 사이를 이동할 수 있음
- 새롭게 진입하는 프로세스는 먼저 우선순위가 가장 높은 우선순위 큐에 삽입되고 타임 슬라이스 동안 실행
- 해당 큐에서 프로세스 실행이 끝나지 않으면 다음 우선순위 큐에 삽입되어 실행 → 계속 반복
- 오래 CPU를 사용해야 하는 프로세스의 우선순위가 점차 낮아짐
- 아사 현상을 예방하기 위해 에이징 기법 적용 가능

## 3. 리눅스 CPU 스케줄링

- 스케줄링 정책 : 새로운 프로세스를 언제 어떻게 선택하여 실행할지를 결정하기 위한 규칙의 집합
- SCHED_FIFO, SCHED_RR
    - RT 스케줄러에 의해 이뤄지는 스케줄링
    - 실시간성이 강조된 프로세스에 적용되는 스케줄링 정책
- SCHED_NORMAL
    - 일반적인 프로세스에 적용되는 스케줄링 정책
    - CFS라는 CPU 스케줄러에 의해 스케줄링 이뤄짐
    - CFS : 프로세스에 대해 완전히 공평한 CPU 시간 배분을 지향하는 CPU 스케줄러
    - CFSSMS 가상 실행 시간(vruntime)이 가장 작은 프로세스부터 스케줄링
    - vruntime : 프로세스가 실제로 시행된 시간이 아닌 프로세스의 가중치를 고려한 가상의 실행 시간
    - 프로세스 우선순위 높아짐 → 프로세스 가중치 높아짐 → vruntime 증가 → 타임 슬라이스 크게 할당
- SCHED_BATCH : 일반적인 프로세스만큼 자주 선점하지 않는 배치 작업에 적용되는 정책
- SCHED_IDLE : 우선순위가 매우 낮은 프로세스에 적용되는 정책

# 5. 가상 메모리

## 1. 물리 주소와 논리 주소

- 물리 주소 : 메모리의 하드웨어 상 실제 주소
- 논리 주소 : 프로세스마다 부여되는 0번지부터 시작하는 주소 체계
- 메모리 관리 장치(MMU) : CPU와 메모리 사이에 위치, CPU가 이해하는 논리 주소를 메모리가 이해하는 물리 주소로 변환하는 역할

## 2. 스와핑과 연속 메모리 할당

### 스와핑

- 스왑 영역 : 보조기억장치의 일부인 영역
- 스와핑 : 프로세스를 쫓아낸 자리에 생긴 메모리 상의 빈 공간에 다른 프로세스를 적재하여 실행하는 메모리 관리 방식
- 스왑 아웃 : 현재 실행되지 않는 프로세스가 메모리에서 스왑 영역으로 옮겨지는 것
- 스왑 인 : 스왑 영역에 있는 프로세스가 다시 메모리로 옮겨오는 것

### 연속 메모리 할당과 외부 단편화

- 연속 메모리 할당 : 프로세스에 연속적인 메모리 공간을 할당하는 방식
- 외부 단편화 : 프로세스들이 메모리에 연속적으로 할당되는 환경에서 프로세스의 실행과 종료를 반복하며 메모리 사이 사이에 빈 공간이 생기고, 그보다 큰 프로세스를 적재하기 어려운 상황이 발생하는 것

## 3. 페이징을 통한 가상 메모리 관리

### 개요

- 적재와 삭제를 반복하며 프로세스들 사이에 발생하는 외부 단편화
- 물리 메모리보다 큰 프로세스 실행 불가
- 가상 메모리 : 실행하고자 하는 프로그램의 일부만 메모리에 적재해, 실제 메모리보다 더 큰 프로세스를 실행할 수 있도록 만드는 메모리 관리 기법
- 보조기억장치의 일부를 메모리처럼 사용, 프로세스의 일부만 메모리에 적재 → 메모리를 실제 크기보다 더 크게 보이게 하는 기술

### 세그멘테이션

- 프로세스를 일정한 크기의 페이지 단위가 아닌 가변적인 크기의 세그먼트 단위로 분할하는 방식

### 페이징

- 프로세스의 논리 주소 공간을 페이지라는 일정한 단위로 나누고, 물리 주소 공간을 페이지와 동일한 크기의 프레임이라는 일정한 단위로 나눈 뒤 페이지를 프레임에 할당하는 가상 메모리 관리 기법
- 페이지 아웃 : 페이지 단위로 스왑 아웃
- 페이지 인 : 페이지 단위로 스왑 인
- 프로세스를 실행하기 위해 전체 프로세스가 메모리에 적재될 필요는 없음

### 페이지 테이블

- 프로세스의 페이지와 실제로 적재된 프레임을 짝지어주는 정보
- 페이지 번호와 실제로 적재된 프레임 번호 대응
- 테이블 엔트리(PTE) : 페이지 테이블을 구성하고 있는 각각의 행
- 페이지 번호, 프레임 번호, 유효 비트, 보호 비트, 참조 비트, 수정 비트 포함
- 유효 비트
    - 해당 페이지에 접근이 가능한지 여부를 알려 주는 매우 중요한 정보
    - 현재 페이지가 메모리, 아니면 보조기억장치에 적재되어 있는지 알려 주는 비트
    - 페이지가 메모리에 적재되어 있다면 1, 아니면 0
    - 페이지 폴트 : CPU가 메모리에 적재되지 않은 페이지, 유효 비트가 0인 페이지에 접근하려고 하는 것
    - 기존 작업 내역 백업 → 원하는 페이지를 메모리로 가져와 유효 비트를 1로 변경해 주는 작업 → 페이지 폴트 처리 루틴 실행 후, 메모리에 적재된 페이지 실행
- 보호 비트
    - 페이지 보호 기능을 위해 존재하는 비트
    - 읽기를 나타내는 r, 쓰기를 나타내는 w, 실행을 나타내는 x의 조합으로 페이지에 접근할 권한 제한
- 참조 비트
    - CPU가 해당 페이지에 접근한 적이 있는지의 여부를 나타내는 비트
    - 페이지에 적재한 이후에 CPU가 읽거나 쓴 페이지는 참조 비트 1로 설정, 적재한 이후에 한 번도 읽거나 쓴 적이 없는 페이지는 0 유지
- 수정 비트(더티 비트)
    - 해당 페이지에 데이터를 쓴 적이 있는지의 여부를 알려 주는 비트
    - 수정 비트가 1인 경우 변경된 적이 있는 페이지, 0인 경우 변경된 적이 없는 페이지
    - 수정 비트 1 → 보조기억장치에 대한 쓰기 작업 필요
    - 수정 비트 0 → 보조기억장치에 대한 별도 쓰기 작업 없이 페이지를 메모리에서 삭제 가능
- 내부 단편화 : 페이지 하나의 크기보다 작은 크기로 발생하게 되는 메모리 낭비
- 페이지 테이블 베이스 레지스터(PTBR) : 특정 프로세스의 페이지 테이블이 적재된 메모리 상의 위치를 가리키는 특별한 레지스터
- PTBR은 프로세스마다 가지는 정보 → 각 PCB에 기록, 다른 프로세스로의 문맥 교환 발생 시 변경
- 메모리 접근 횟수
    - 모든 프로세스의 페이지 테이블이 메모리에 적재되어 있을 경우, CPU는 페이지 테이블에 접근하기 위해 한 번, 실제 프레임에 접근하기 위해 한 번 → 총 두 번 메모리에 접근
    - TLB : 페이지 테이블의 캐시 메모리 사용
    - TLB 히트 : CPU가 접근하려는 논리 주소의 페이지 번호가 TLB에 있을 경우, TLB는 CPU에게 해당 페이지 번호가 적재된 프레임 번호를 알려줌
    - TLB 미스 : 페이지 번호가 TLB에 없는 경우, 페이지가 적재된 프레임을 알기 위해 메모리 내의 페이지 테이블에 접근하는 것
- 메모리 용량
    - 계층적 페이징(다단계 페이지 테이블) : 페이지 테이블을 페이징하는 방식, 여러 단계의 페이지를 둠
    - 프로세스의 페이지 테이블을 여러 개의 페이지로 자르고, CPU와 가까이 위치한 바깥 쪽에 페이지 테이블을 하나 더 두어 잘린 페이지 테이블의 페이지들을 가리키게 함

### 페이징 주소 체계

- 페이지 번호 : 몇 번째 페이지 번호에 접근할지 나타냄
- 변위 : 접근하려는 주소가 페이지 시작 번지로부터 얼만큼 떨어져 있는지를 나타내는 정보

## 4. 페이지 교체 알고리즘

- 요구 페이징 : 메모리에 프로세스를 적재할 때 처음부터 모든 페이지를 적재하지 않고, 메모리에 필요한 페이지만을 적재하는 기법
    - CPU가 특정 페이지에 접근하는 명령어 실행
    - 해당 페이지가 현재 메모리에 있을 경우 CPU는 페이지가 적재된 프레임에 접근
    - 해당 페이지가 현재 메모리에 없을 경우 페이지 폴트 발생
    - 페이지 폴트 발생 시 페이지 폴트 처리 루틴을 통해 해당 페이지를 메모리로 적재, 유효 비트 1로 설정
    - 다시 처음부터 수행
- 순수 요구 페이징 : 아무런 페이지도 메모리에 적재하지 않은 채 무작정 프로세스를 실행하는 것
- 페이지 교체 알고리즘 : 메모리에 적재된 페이지 중 보조기억장치로 내보낼 페이지를 선택하는 방법
    - FIFO 페이지 교체 알고리즘 : 메모리에 가장 먼저 적재된 페이지부터 스왑 아웃하는 페이지 교체 알고리즘
    - 최적 페이지 교체 알고리즘 : 앞으로의 사용 빈도가 가장 낮은 페이지를 교체하는 알고리즘
    - LRU 페이지 교체 알고리즘 : 가장 적게 사용한 페이지를 교체하는 알고리즘
- 페이지 폴트
    - 메이저 페이지 폴트 : 보조기억장치에서 CPU가 원하는 페이지를 읽어 들이기 위해 입출력 작업이 필요한 페이지 폴트
    - 마이너 페이지 폴트 : 보조기억장치와의 입출력이 필요하지 않은 페이지 폴트

# 6. 파일 시스템

## 1. 파일과 디렉터리

### 파일

- 파일 시스템 : 보조기억장치의 정보를 파일 및 디렉터리의 형태로 저장하고 관리할 수 있도록 하는 운영체제 내부 프로그램
- 파일 : 파일의 이름, 파일을 실행하기 위한 정보, 파일과 관련한 부가 정보로 구성
- 속성(메타데이터) : 파일과 관련한 부가 정보, 파일의 형식, 위치, 크기 등의 정보
- 파일 디스크립터 : 저수준에서 파일을 식별하는 정보, 0 이상의 정수 형태
- 프로세스가 새로 파일을 열거나 생성할 때 해당 파일에 대한 파일 디스크립터를 프로세스에 할당

### 디렉터리(폴더)

- 여러 파일을 관리하기 위한 형태
- 트리 구조 디렉터리 : 최상위 디렉터리 + 서브 디렉터리
    - 루트 디렉터리 : 최상위 디렉터리, 슬래시(/)로 표현
    - 경로 : 디렉터리 정보를 활용해 파일 위치를 특정하는 정보
- 디렉터리 엔트리
    - 디렉터리에 속한 요소의 관련 정보가 테이블 형태로 표현되고, 그 표현된 정보의 행
    - 파일 이름, 파일이 저장된 위치를 유추할 수 있는 정보 반드시 포함
    - 파일 속성도 포함 가능(생성 시간, 수정 시간, 크기 등)

### 파일 할당

- 블록 : 운영체제가 파일과 디렉터리를 읽고 쓰는 단위
- 하나의 파일이 보조기억장치에 저장될 때 하나 이상의 블록을 할당받아 저장
- 연결 할당 : 각 블록의 일부에 다음 블록의 주소를 저장하여 각각의 블록이 다음 블록을 가리키는 형태
- 색인 블록 : 파일을 이루는 모든 블록의 주소
- 색인 할당 : 색인 블록이라는 특별한 블록에 모아 관리하는 방식

## 2. 파일 시스템

### 개요

- 파이셔닝 : 보조기억장치의 영역을 구획하는 작업
- 파티션 : 파티셔닝되어 나누어진 하나의 영역
- 포매팅 : 파일 시스템을 설정하여 어떤 바잇ㄱ으로 파일을 저장하고 관리할 것인지를 결정하고, 새로운 데이터를 쓸 준비를 하는 작업

### 아이노드 기반 파일 시스템

- 파일이 저장된 위치와 속성 등의 사실상 파일의 모든 것 포함
- 데이터 영역에 공간이 남아 있더라도 아이노드 영역이 가득 차 더 이상의 아이노드를 할당할 수 없으면 운영체제는 새로운 파일 생성 불가
- 하드 링크 파일 : 원본 파일과 같은 아이노드를 공유하는 파일
- 심볼릭 링크 파일 : 원본 파일을 가리키는 파일

### 마운트

- 어떤 저장장치의 파일 시스템에서 다른 저장장치의 파일 시스템으로 접근할 수 있도록 파일 시스템을 편입시키는 작업