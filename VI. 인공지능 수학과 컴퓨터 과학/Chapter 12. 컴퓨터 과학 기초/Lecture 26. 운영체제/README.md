# 1. 운영체제 개요

## 1. 운영체제의 역할

### 개요

- 커널 : 운영체제의 핵심 기능을 담당하는 부분
- 자원 : 프로그램 실행에 마땅히 필요한 요소

### CPU 관리 : CPU 스케줄링

- 실행 중인 모든 프로그램들이 공정하고 합리적으로 CPU를 할당받도록 CPU의 할당 순서와 사용 시간 결정

### 메모리 관리 : 가상 메모리

- 실제 물리적인 메모리 크기보다 더 큰 메모리를 이용할 수 있도록 하는 기술

### 파일/디렉터리 관리 : 파일 시스템

- 보조기억장치 내의 정보를 파일 및 폴더 단위로 접근/관리할 수 있도록 만드는 운영체제 내부 프로그램

### 프로세스 및 스레드 관리

- 프로세스 : 실행 중인 프로그램
- 스레드 : 프로세스를 이루는 실행 단위
- 프로세스와 스레드가 올바르게 처리되도록 실행의 순서를 제어하고 자원을 적절하게 배분

## 2. 시스템 콜과 이중 모드

- 커널 영역 : 사용자 프로그램이 아닌 운영체제가 적재되는 메모리 공간
- 사용자 영역 : 운영체제가 적재되는 커널 영역 외에 사용자 응용 프로그램이 적재되는 공간
- 시스템 콜 : 운영체제의 서비스를 제공 받기 위한 수단, 호출 가능한 함수 형태
- 부모 프로세스 : 새 프로세스를 생성한 프로세스
- 자식 프로세스 : 부모 프로세스에 의해 생성된 프로세스
- 소프트웨어 인터럽트 : 명령어에 의해 발생하는 인터럽트, 자원에 접근하는 입출력 명령어
- 사용자 영역 실행 중 시스템 콜 호출 → 현재 수행 중인 작업 백업 → 커널 영역 내의 인터럽트를 처리하기 위한 코드 실행 → 다시 사용자 영역 코드 실행
- 사용자 모드
    - 사용자 영역에 적재된 코드를 실행할 때의 실행 모드
    - 운영체제 서비스를 제공받을 수 없는 실행 모드
- 커널 모드
    - 커널 영역에 적재된 코드를 실행할 때의 실행 모드
    - 운영체제 서비스를 제공받을 수 있는 실행 모드
- 이중 모드 : 사용자 모드, 커널 모드 2개의 모드로 구분하여 실행하는 것

# 2. 프로세스와 스레드

## 1. 프로세스

### 개요

- 포그라운드 프로세스 : 사용자가 보는 공간에서 사용자와 상호작용하며 실행
- 백그라운드 프로세스 : 사용자가 보지 못하는 곳에서 실행
- 데몬(서비스) : 백그라운드 프로세스 중 사용자와 별다른 상호작용 없이 주어진 작업만 수행하는 특별한 백그라운드 프로세스
- 코드 영역(텍스트 영역)
    - 실행 가능한 명령어가 저장되는 공간
    - CPU가 읽고 실행할 명령어 보관 → 읽기 전용 공간
- 데이터 영역
    - 프로그램이 실행되는 동안 유지할 데이터가 저장되는 공간
    - 정적 변수, 전역 변수 → 초기값이 있는 데이터
- BSS 영역
    - 프로그램을 사용하는 동안 유지할 데이터 중 초기값이 없는 데이터가 저장되는 공간
- 힙 영역
    - 프로그램을 만드는 사용자가 직접 할당 가능한 저장 공간
    - 프로그램 실행 도중 비교적 자유롭게 할당하여 사용 가능한 메모리 공간
    - 메모리 누수 : 메모리 공간 미반환 시 할당한 공간이 계속 메모리 내에 남아 메모리를 낭비하는 것
- 스택 영역
    - 데이터 영역에 담기는 값과는 달리 일시적으로 사용할 값들이 저장되는 공간
    - 매개변수, 지역 변수, 함수 복귀 주소
    - 스택 트레이스 형태의 함수 호출 정보 저장 가능
    - 스택 트레이스 : 특정 시점에 스택 영역에 저장된 함수 호출 정보

### PCB와 문맥 교환

- 프로세스 제어 블록(PCB)
    - 프로세스와 관련한 다양한 정보를 내포하는 구조체의 일종
    - 새로운 프로세스가 메모리에 적재됐을 때 커널 영역에 만들어지고, 프로세스의 실행이 끝나면 폐기
- PCB에 담기는 정보
    - 프로세스 ID(PID) : 프로세스 식별 번호
    - 프로세스가 실행 과정에서 사용한 레지스터 값
    - 프로세스 상태 : 프로세스가 현재 어떤 상태인지를 나타냄
    - CPU 스케줄링 정보 : 프로세스가 언제, 어떤 순서로 CPU를 할당받을지 나타냄
    - 메모리 관련 정보 : 프로세스의 메모리상 적재 위치 확인
    - 프로세스가 사용한 파일 및 입출력장치 관련 정보
- 프로세스 테이블 : 실행 중인 PCB의 모음
- 프로세스 실행 : 운영체제에 의해 CPU의 자원을 할당받음
- 타이머 인터럽트(타임아웃 인터럽트) : 시간이 끝났음을 알리는 인터럽트
- 프로세스는 자신의 차례가 되면 정해진 시간만큼 CPU 사용 → 타이머 인터럽트 발생 시 자신의 차례 양보 후 다음 차례가 올 때까지 대기
- 문맥 : 백업 대상이 되는 중간 정보, 프로세스의 수행을 재개하기 위해 기억해야 할 정보
- 프로세스가 CPU 사용 시간이 다 되거나 인터럽트 발생 → 운영체제는 해당 프로세스의 PCB에 문맥 백업 → 실행할 프로세스의 문맥 복구
- 문맥 교환 : 기존 프로세스의 문맥을 PCB에 백업하고, PCB에서 문맥을 복구하여 새로운 프로세스를 실행하는 것
- 프로세스 간 잦은 문맥 교환 → 캐시 미스 발생 가능성 증가 → 큰 오버헤드 발생

### 프로세스의 상태

- 생성 상태(new)
    - 프로세스를 생성 중인 상태
    - 메모리에 적재되어 PCB를 할당받은 상태
    - 실행 준비가 완료된 프로세스는 준비 상태가 되어 CPU 할당 대기
- 준비 상태(ready)
    - CPU를 할당받아 실행할 수 있지만, 자신의 차례가 아니라 기다리고 있는 상태
    - 준비 상태인 프로세스가 CPU를 할당받으면 실행 상태가 됨
    - 디스패치 : 준비 상태인 프로세스가 실행 상태로 전환되는 것
- 실행 상태(running)
    - CPU를 할당받아 실행 중인 상태
    - 일정 시간 동안만 CPU를 사용할 수 있음
    - 타이머 인터럽트 발생 → 프로세스가 할당된 시간 모두 사용 → 준비 상태 전환
    - 실행 도중 입출력장치 사용 → 입출력장치 작업 종료까지 대기 → 대기 상태 전환
- 대기 상태(blocked)
    - 곧장 실행이 불가능한 조건에 놓이는 경우
    - 입출력 작업 요청, 바로 확보할 수 없는 자원 요청
    - 실행 가능한 상태 → 준비 상태 → CPU 할당 대기
- 종료 상태(terminated)
    - 프로세스가 종료된 상태
    - 운영체제는 PCB와 프로세스가 사용한 메모리 정리
- 블로킹 입출력 : 프로세스가 실행 도중 입출력 작업 수행 시 대기 상태로 전환 후, 입출력 작업 완료 시 준비 상태가 되어 실행 재개
- 논블로킹 입출력 : 입출력장치에게 입출력 작업을 맡긴 뒤, 곧바로 이어질 명령어 실행하는 것

## 2. 멀티프로세스와 멀티스레드

- 멀티프로세스
    - 동시에 여러 프로세스가 실행되는 것
    - 자원을 공우하지 않고, 독립적으로 실행
    - 한 프로세스에 문제가 생겨도 다른 프로세스에는 지장이 없거나 적음
- 멀티스레드
    - 프로세스를 동시에 실행하는 여러 스레드
    - 프로세스 자원 공유
    - 한 스레드에 생긴 문제가 프로세스 전체 문제가 될 수 있음

## 3. 프로세스 간 통신

### 개요

- 프로세스 간 통신(IPC) : 프로세스 간에도 자원을 공유하고 데이터를 주고 받을 수 있는 방법
    - 공유 메모리 : 데이터를 주고받는 프로세스가 공통적으로 사용할 메모리 영역을 두는 방식
    - 메시지 전달 : 프로세스 간에 주고받을 데이터를 메시지의 형태로 주고받는 방식

### 공유 메모리

- 프로세스 간에 공유하는 메모리 영역을 토대로 데이터를 주고받는 통신 방식
- 특정 프로세스가 다른 프로세스의 메모리 공간을 임의로 수정할 수 없음
- 공유 메모리 할당 → 프로세스가 해당 메모리 공간 공유 및 읽고 쓰기 가능
- 통신을 주고받는 각 프로세스가 마치 자신의 메모리 영역을 읽고 쓰는 것처럼 통신

### 메시지 전달

- 프로세스 간에 주고받을 데이터가 커널을 거쳐 송수신되는 통신 방식
- 메시지를 보내는 수단과 받는 수단이 명확하게 구분
- 주고받는 데이터가 커널을 통해 송수신 → 공유 메모리 기반 IPC보다 통신 속도 느림
- 파이프 : 단방향 프로세스 간 통신 도구
    - 익명 파이프 : 단방향 통신 수단인 전통적인 파이트
    - 지명 파이프 : 익명 파이프를 확장한 파이프, 양방향 통신 지원
- 시그널 : 프로세스에게 특정 이벤트가 발생했음을 알리는 비동기적인 신호
- 시그널 발생 → 하던 일 잠시 중단 → 시그널 처리를 위한 시그널 핸들러 실행 → 실행 재개
- 원격 프로시저 호출(RPC) : 원격 코드를 실행하는 IPC 기술
- 네트워크 소켓을 통한 IPC 수행

# 3. 동기화와 교착 상태

## 1. 개요

- 공유 자원 : 프로세스 혹은 스레드가 공유하는 자원
- 임계 구역 : 공유 자원에 접근하는 코드 중 동시에 실행했을 때 문제가 발생할 수 있는 코드
- 레이스 컨디션 : 프로세스 혹은 스레드가 동시에 임계 구역의 코드를 실행하여 문제가 발생하는 상황
- 동기화 : 아래 2가지 조건을 준수하며 실행하는 것
    - 실행 순서 제어 : 프로세스 및 스레드를 올바른 순서로 실행하기
    - 상호 배제 : 동시에 접근해서는 안 되는 자원에 하나의 프로세스 및 스레드만 접근하기

## 2. 동기화 기법

### 뮤텍스 락

- 동시에 접근해서는 안 되는 자원에 동시 접근이 불가능하도록 상호 배제를 보장하는 동기화 도구
- 임계 구역에 접근하고자 하면 반드시 락을 획득해야 하고, 임계 구역에서의 작업이 끝났다면 락을 해제해야 함
- acquire() 함수 : 락을 획득하기 위한 함수
- release() 함수 : 획득한 락을 해제하기 위한 함수

### 세마포

- 뮤텍스 락과 비슷하지만 조금 더 일반화된 방식의 동기화 도구
- 공유 자원이 여러 개 있는 상황에서도 동기화 가능
- 변수 S : 사용 가능한 공유 자원의 개수를 나타내는 변수
- wait() 함수 : 임계 구역 진입 전 호출하는 함수
- signal() 함수 : 임계 구역 진입 후 호출하는 함수
- 이진 세마포 : S가 0과 1의 값을 가지는 세마포, 뮤텍스 락과 유사하게 동작
- 카운팅 세마포 : 공유 자원이 여러 개 존재하는 경우에 사용할 수 있는 세마포

### 조건 변수와 모니터

- 조건 변수
    - 실행 순서 제어를 위한 동기화 도구
    - 특정 조건 하에 프로세스를 실행/일시 중단함으로써 프로세스나 스레드의 실행 순서 제어 가능
- wait() 함수 : 호출한 프로세스 및 스레드의 상태를 대기 상태로 전환하는 함수
- signal() 함수 : 일시 중지된 프로세스 및 스레드의 실행을 재개하는 함수
- 모니터
    - 공유 자원과 그 공유 자원을 다루는 함수로 구성된 동기화 도구
    - 상호 배제를 위한 동기화뿐만 아니라 실행 순서 제어를 위한 동기화까지 가능

### 스레드 안전

- 멀티스레드 환경에서 어떤 변수나 함수, 객체에 동시 접근이 이루어져도 실행에 문제가 없는 상태

## 3. 교착 상태

### 교착 상태의 발생 조건

- 일어나지 않을 사건을 기다리며 프로세스의 진행이 멈춰 버리는 현상
- 상호 배제 : 한 프로세스가 사용하는 자원을 다른 프로세스가 사용할 수 없는 상태
- 점유와 대기 : 한 프로세스가 어떤 자원을 할당받은 상태에서 다른 자원 할당받기를 기다리는 것
- 비선점 : 해당 자원을 이용하는 프로세스의 작업이 끝나야만 비로소 자원을 이용할 수 있음
- 원형 대기 : 프로세스와 프로세스가 요청한 자원이 원의 형태를 이루는 것

### 교착 상태의 해결 방법

- 교착 상태 예방
    - 교착 상태를 발생시키는 4가지 필요 조건 중 하나를 충족하지 못하게 하는 방법
    - 한 프로세스에 필요한 자원 몰아주기 → 다음 다른 프로세스에 필요한 자원 몰아주기
    - 할당 가능한 모든 자원에 번호를 매기고 오름차순으로 할당
- 교착 상태 회피
    - 교착 상태가 발생하지 않을 정도로만 조심하면서 자원을 할당하는 방법
    - 교착 상태를 한정된 자원의 무분별한 할당으로 인해 발생하는 문제로 간주
- 교착 상태 검출 후 회복
    - 교착 상태의 발생을 인정하고 처리하는 사후 조치
    - 프로세스가 자원을 요구할 때마다 그때 그때 자원을 할당하고 주기적으로 교착 상태의 발생 여부 검사
    - 교착 상태 검출 → 자원 선점으로 회복, 강제 종료

# 4. CPU 스케줄링

## 1. CPU 스케줄링

### 개요

- CPU 스케줄링 : 운영체제의 CPU 배분 방법
- CPU 스케줄링 알고리즘 : CPU 스케줄링 절차
- CPU 스케줄러 : CPU 스케줄링 알고리즘을 결정하고 수행하는 운영체제 일부분

### 우선순위

- 운영체제는 프로세스별 우선순위를 판단하여 PCB에 명시, 우선순위가 높은 프로세스에 CPU의 자원을 더 빨리, 많이 할당
- CPU 활용률 : 전체 CPU의 가동 시간 중 작업을 처리하는 시간의 비율
- 운영체제는 높은 CPU 활용률을 유지하기 위해 기본적으로 입출력 작업이 많은 프로세스의 우선순위를 높게 유지
- CPU 버스트 : 프로세스가 CPU를 이용하는 작업
- 입출력 버스트 : 입출력장치를 기다리는 작업
- 입출력 집중 프로세스
    - 입출력 작업이 많은 프로세스
    - 비디오 재생, 디스크 백업 작업
    - 실행 상태보다 입출력을 위한 대기 상태에 더 많이 머무름
- CPU 집중 프로세스
    - CPU 작업이 많은 프로세스
    - 복잡한 수학 연산, 그래픽 처리 작업
    - 대기 상태보다 실행 상태에 더 많이 머무름
- 입출력 집중 프로세스를 가능한 빨리 실행시켜 끊임없이 입출력장치를 작동시킨 다음, CPU 집중 프로세스에 집중적으로 CPU를 할당하는 것이 더 합리적

### 스케줄링 큐

- CPU를 이용하고 싶은 프로세스의 PCB와 메모리로 적재되고 싶은 프로세스의 PCB, 특정 입출력장치를 이용하고 싶은 프로세스의 PCB를 큐에 삽입하여 줄 세우는 것
- 준비 큐 : CPU를 이용하고 싶은 프로세스의 PCB가 서는 줄
- 대기 큐 : 대기 상태에 접어든 프로세스의 PCB가 서는 줄
- 운영체제는 큐에 삽입된 순서대로 실행하되, 우선순위가 높은 프로세스부터 먼저 실행

### 선점형 스케줄링과 비선점형 스케줄링

- 선점형 스케줄링
    - 현재 어떤 프로세스가 CPU를 할당받아 사용하고 있더라도 운영체제가 프로세스로부터 CPU 자원을 강제로 빼앗아 다른 프로세스에 할당할 수 있는 스케줄링
    - 타이머 인터럽트 기반 스케줄링
    - 한 프로세스의 CPU 독점을 막고 여러 프로세스에 골고루 CPU 자원을 배분할 수 있음
    - 문맥 교환 과정에서 오버헤드 발생 가능성 높음
- 비선점형 스케줄링
    - 어떤 프로세스가 CPU를 사용하고 있을 때 그 프로세스가 종료되거나 스스로 대기 상태에 접어들기 전까지는 다른 프로세스가 끼어들 수 없는 스케줄링 방식
    - 문맥 교환 횟수가 적기 때문에 상대적으로 오버헤드 발생 가능성 낮음
    - 당장 CPU를 사용해야 하는 프로세스라도 무작정 기다려야 함

## 2. CPU 스케줄링 알고리즘

### 선입 선처리 스케줄링(FCFS)

- 준비 큐에 삽입된 순서대로 먼저 CPU를 요청한 프로세스부터 CPU를 할당하는 스케줄링 방식
- 호위 효과 : 먼저 삽입된 프로세스의 오랜 실행 시간으로 인해 나중에 삽입된 프로세스의 실행이 지연되는 문제

### 최단 작업 우선 스케줄링(SJF)

- 준비 큐에 삽입된 프로세스 중 CPU를 이용하는 시간의 길이가 가장 짧은 프로세스부터 먼저 실행하는 스케줄링 방식
- 기본적으로 비선점형 스케줄링 알고리즘으로 분류, 최소 잔여 시간 우선 스케줄링처럼 선점형으로도 구현 가능

### 라운드 로빈 스케줄링(RR)

- 큐에 삽입된 프로세스들이 삽입된 순서대로 CPU를 이용하되, 정해진 타임 슬라이스만큼만 CPU를 이용하는 선점형 스케줄링
- 타임 슬라이스 : 프로세스가 CPU를 사용하도록 정해진 시간

### 최소 잔여 시간 우선 스케줄링(SRT)

- 프로세스로 하여금 정해진 타임 슬라이스만큼 CPU를 이용하되, 남아 있는 작업시간이 가장 적은 프로세스를 다음으로 CPU를 이용할 프로세스로 선택하는 방식

### 우선순위 스케줄링

- 프로세스에 우선순위를 부여하고, 가장 높은 우선순위를 가진 프로세스부터 실행하는 스케줄링 방식
- 아사 현상 : 우선순위가 낮은 프로세스는 우선순위가 높은 프로세스로 인해 계속해서 실행이 연기되는 것
- 에이징 : 오랫동안 대기한 프로세스의 우선순위를 점차 높이는 방식

### 다단계 큐 스케줄링

- 우선순위별로 여러 개의 준비 큐를 사용하는 스케줄링 방식
- 우선순위가 가장 높은 큐에 있는 프로세스 먼저 처리, 우선순위가 가장 높은 큐가 비어 있을 경우 그 다음으로 우선순위가 높은 큐에 있는 프로세스 처리
- 프로세스들이 큐 사이를 이동할 수 없음 → 아사 현상 발생 가능

### 다단계 피드백 큐 스케줄링

- 다단계 큐 스케줄링과 비슷하게 동작, 프로세스들이 큐 사이를 이동할 수 있음
- 새롭게 진입하는 프로세스는 먼저 우선순위가 가장 높은 우선순위 큐에 삽입되고 타임 슬라이스 동안 실행
- 해당 큐에서 프로세스 실행이 끝나지 않으면 다음 우선순위 큐에 삽입되어 실행 → 계속 반복
- 오래 CPU를 사용해야 하는 프로세스의 우선순위가 점차 낮아짐
- 아사 현상을 예방하기 위해 에이징 기법 적용 가능

## 3. 리눅스 CPU 스케줄링

- 스케줄링 정책 : 새로운 프로세스를 언제 어떻게 선택하여 실행할지를 결정하기 위한 규칙의 집합
- SCHED_FIFO, SCHED_RR
    - RT 스케줄러에 의해 이뤄지는 스케줄링
    - 실시간성이 강조된 프로세스에 적용되는 스케줄링 정책
- SCHED_NORMAL
    - 일반적인 프로세스에 적용되는 스케줄링 정책
    - CFS라는 CPU 스케줄러에 의해 스케줄링 이뤄짐
    - CFS : 프로세스에 대해 완전히 공평한 CPU 시간 배분을 지향하는 CPU 스케줄러
    - CFSSMS 가상 실행 시간(vruntime)이 가장 작은 프로세스부터 스케줄링
    - vruntime : 프로세스가 실제로 시행된 시간이 아닌 프로세스의 가중치를 고려한 가상의 실행 시간
    - 프로세스 우선순위 높아짐 → 프로세스 가중치 높아짐 → vruntime 증가 → 타임 슬라이스 크게 할당
- SCHED_BATCH : 일반적인 프로세스만큼 자주 선점하지 않는 배치 작업에 적용되는 정책
- SCHED_IDLE : 우선순위가 매우 낮은 프로세스에 적용되는 정책
