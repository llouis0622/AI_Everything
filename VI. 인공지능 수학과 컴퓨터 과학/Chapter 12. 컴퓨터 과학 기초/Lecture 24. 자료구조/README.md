# 1. 자료구조 개요

## 1. 자료구조와 알고리즘

- 자료구조 : 어떠한 구조로 데이터를 다룰지에 대해 학습하는 과목
- 알고리즘 : 어떠한 목적을 이루기 위해 필요한 일련의 연산 절차

## 2. 시간 복잡도와 공간 복잡도

- 시간 복잡도 : 입력의 크기에 따른 프로그램 시행 시간의 관계
- 빅 오 표기법
    - 함수의 점근적 상한을 표기하는 방법
    - 입력에 따른 실행 시간의 점근적 상한
    - 실행 시간이 대략 이 이상은 커지지 않을 것
    - 최고차항의 차수만 고려
- 빅 세타 표기법 : 입력에 대한 평균적인 실행 시간
- 빅 오메가 표기법 : 입력에 대한 실행 시간의 점근적 하한
- 공간 복잡도 : 프로그램이 실행되었을 때 필요한 메모리 자원의 양

# 2. 배열과 연결 리스트

## 1. 배열

- 일정한 메모리 공간을 차지하는 여러 요소들이 순차적으로 나열된 자료구조
- 0부터 시작하는 고유한 순서 번호인 인덱스로 배열 요소 식별
- 특정 요소 접근 : O(1)
- 특정 요소 수정 : O(1)
- 특정 요소 찾기 : O(N)
- 특정 요소 추가/삭제 : O(N)
- 정적 배열 : 프로그램을 실행하기 전에 크기가 고정되어 있는 배열
- 동적 배열 : 실행 과정에서 크기가 변할 수 있는 배열

## 2. 연결 리스트

- 노드의 모음으로 구성된 자료구조
- 노드 : 저장하고자 하는 데이터와 다음 노드의 위치 정보를 포함하는 연결 리스트의 구성 단위
- 모든 노드들이 한 쪽 방향으로 꼬리에 꼬리를 무는 형태로 구성
- 연결 리스트의 첫 번째 노드는 헤드, 마지막 노드는 꼬리
- 연속적으로 구성되어 있는 데이터를 불연속적으로 저장할 때 유용
- 특정 요소 접근 : O(N)
- 특정 요소 추가/삭제 : O(1)
- 싱글 연결 리스트
    - 노드 내에 다음 노드의 위치 정보가 저장된 한 쪽 방향으로 이루어진 형태
    - 단방향 탐색
- 이중 연결 리스트
    - 노드 내에 다음 노드의 위치 정보와 이전 노드의 위치 정보를 포함
    - 양방향 탐색 가능
    - 한 노드에 2개의 위치 정보 저장 → 저장 공간 더 필요
- 환형 연결 리스트
    - 꼬리 노드가 헤드 노드를 가리켜 노드들이 원형으로 구성된 연결 리스트
    - 모든 노드 데이터를 여러 차례 순회해야 할 때 유리

# 3. 스택과 큐

## 1. 스택

- 한 쪽에서만 데이터의 삽입 및 삭제가 가능한 자료구조
- 푸시 : 데이터를 저장하는 연산
- 팝 : 데이터를 빼내는 연산
- 후입선출(LIFO) 자료구조
- 최근에 임시 저장한 데이터를 가장 먼저 활용해야 할 때
- 뒤로가기 기능을 만들고 싶을 때

## 2. 큐

- 한 쪽으로 데이터를 삽입하고, 다른 한 쪽으로 데이터를 삭제할 수 있는 자료구조
- 선입선출(FIFO) 자료구조
- 인큐 : 큐의 한 쪽 끝에 데이터를 삽입하는 연산
- 디큐 : 다른 한 쪽 끝으로 데이터를 빼내는 연산
- 임시 저장된 데이터를 차례차례 내보내거나 꺼내 와야 하는 버퍼로 활용 가능
- 원형 큐 : 데이터를 삽입하는 쪽과 삭제하는 쪽, 양쪽을 하나로 연결해 원형으로 사용하는 자료구조
- 덱 : 양방향 큐, 양쪽으로 데이터를 삽입/삭제할 수 있는 큐
- 우선순위 큐 : 정해진 우선순위가 높은 순으로 처리되는 큐

# 4. 해시 테이블

## 1. 해시 테이블

- 키와 값의 대응으로 이루어진 표와 같은 형태의 자료구조
- 키 : 해시 테이블에 대한 입력
- 값 : 키를 통해 얻고자 하는 데이터
- 키를 통해 얻고자 하는 데이터는 버킷에 저장
- 버킷은 여러 개 존재, 여러 버킷은 배열 형성

## 2. 해시 함수

- 해시 함수 : 임의의 길이를 지닌 데이터를 고정된 길이의 데이터로 변환하는 단방향 함수
- 특정 입력 데이터를 고정된 길이의 해시 값 변환 가능
- 해시 값을 토대로 어떤 데이터가 입력되었는지 도출 불가능
- 해시 알고리즘 : 해시 함수의 연산 방법
- 해시 테이블을 활용한 검색, 삽입, 삭제 : O(1)
- 속도가 빠른 만큼 상대적으로 많은 메모리 공간 소모

## 3. 해시 충돌

- 서로 다른 키에 대해 같은 해시 값이 대응되는 상황
- 2개 이상의 키에 같은 데이터가 대응되는 상황 발생
- 체이닝
    - 충돌이 발생한 데이터를 연결 리스트로 추가하는 방법
    - 서로 다른 키가 같은 위치로 해시되어도 연결 리스트의 노드에 추가
    - 충돌이 발생할 때마다 연결 리스트 노드 추가 → 빠른 속도 장점 저하
- 개방 주소법
    - 충돌이 발생한 버킷의 인덱스가 아닌 다른 인덱스에 데이터를 저장하는 방법
    - 조사 : 충돌이 발생했을 때 비어 있는 다른 버킷의 인덱스를 찾는 과정
    - 선형 조사법 : 충돌이 발생한 인덱스의 다음 인덱스부터 순차적으로 가용한 인덱스를 찾는 방법
    - 군집화 : 해시 충돌이 발생하는 인덱스 인근에 충돌이 발생한 여러 데이터가 몰려 저장되는 것
    - 이차 조사법 : 충돌이 발생한 인덱스에서 제곱수만큼 떨어진 거리에 위치한 인덱스를 찾는 방법
    - 이중 해싱 : 2개의 해시 함수를 사용하는 방법, 충돌이 발생했을 때 다른 해시 함수에 대한 해시 값만큼 떨어진 거리에 위치한 인덱스를 찾는 방법

# 5. 트리

## 1. 개요

- 트리 : 주로 계층적인 구조를 표현하기 위한 자료구조
- 노드 : 트리 자료구조에서 데이터를 저장하는 구성 요소
- 간선 : 트리 자료구조에서 노드를 연결하는 구성 요소
- 부모 노드 : 어떤 노드의 상위에 연결된 노드
- 자식 노드 : 어떤 노드의 하위에 연결된 노드
- 루트 노드 : 트리의 최상위 노드, 부모 노드가 없는 노드
- 리프 노드 : 트리의 최하위 노드, 자식 노드가 없는 노드
- 차수 : 어떤 노드가 가지고 있는 자식 노드의 수
- 레벨 : 루트 노드에서 시작해 특정 노드에 이르기까지 거치게 되는 간선의 수
- 서브트리 : 트리에 포함되어 있는 부분 트리
- 하나의 노드를 데이터를 저장할 공간과 자식 노드의 위치 정보를 저장할 공간의 모음으로 구성

## 2. 트리의 순회

- 트리의 순회 : 트리의 모든 노드를 한 번씩 방문하는 것
- 전위 순회 : 루트 노드 → 왼쪽 서브트리 전위 순회 → 오른쪽 서브트리 전위 순회
- 중위 순회 : 왼쪽 서브트리 중위 순회 → 루트 노드 → 오른쪽 서브트리 중위 순회
- 후위 순회 : 왼쪽 서브트리 후위 순회 → 오른쪽 서브트리 후위 순회 → 루트 노드
- 레벨 순서 순회 : 가장 낮은 레벨부터 차례로 노드를 순회하는 방법

## 3. 트리의 종류

### 이진 트리

- 자식 노드의 개수가 2개 이하인 트리
- 편향된 이진 트리 : 모든 자식 노드가 한 쪽으로 치우친 이진 트리
- 정 이진 트리 : 자식 노드의 개수가 1개가 아닌 이진 트리, 자식 노드의 수가 0개 또는 2개
- 포화 이진 트리 : 리프 노드를 제외한 모든 노드들이 자식 노드를 2개씩 가지고 있고, 모든 리프 노드의 레벨이 동일한 이진 트리
- 완전 이진 트리 : 마지막 레벨을 제외한 모든 레벨이 2개의 자식 노드를 가지고 있으며, 마지막 레벨의 모든 노드들이 왼쪽부터 존재하는 이진 트리

### 탐색에 활용되는 트리 : 이진 탐색 트리와 힙

- 이진 탐색 트리(BST)
    - 특정 노드의 왼쪽에는 해당 노드보다 작은 값, 오른쪽에는 해당 노드보다 큰 값이 있는 트리
    - 원하는 값 탐색 : O(log N)
- 힙
    - 완전 이진 트리의 종류 중 하나
    - 최댓값과 최솟값을 빠르게 찾기 위해 사용
    - 원하는 값 탐색 : O(log N)
    - 최대 힙 : 부모 노드가 자식 노드의 값보다 큰 값으로 이루어진 이진 트리
    - 최소 힙 : 부모 노드가 자식 노드의 값보다 작은 값으로 이루어진 이진 트리

### 균형을 맞추는 트리 : RB 트리

- 삽입, 삭제 연산 반복 → 편향된 트리 가능 → 트리 구조 이점 없음
- 자가 균형 이진 탐색 트리 : 왼쪽 서브트리와 오른쪽 서브트리 높이의 균형을 맞추는 특별한 이진 탐색 트리
- AVL 트리
- RB 트리
    - 모든 노드를 빨간색 혹은 검은색으로 칠한 트리
    - 노드에 색을 칠하는 규칙과 노드에 칠해진 색을 기준으로 왼쪽 서브트리와 오른쪽 서브트리 높이의 균형을 맞춤
    - 루트 노드는 블랙 노드
    - 리프 노드는 블랙 노드
    - 레드 노드의 자식 노드는 블랙 노드
    - 어떤 노드에서의 임의의 리프 노드에 이르는 경로의 블랙 노드 수는 동일
    - RB 트리의 리프 노드는 실질적인 데이터가 저장되어 있지 않은 노드인 NIL 노드
    - 새 노드 삽입 시 삽입할 노드를 레드로 간주, 일반 이진 탐색 트리와 동일하게 삽입 수행
    - 노드 삽입 이후에도 RB 트리를 유지해야 함 → 4개의 RB 트리 조건 부합 확인
    - 조건 미부합 시 부합할 때까지 트리 회전 및 색상 재지정

### 대용량 입출력을 위한 트리 : B 트리

- 균형을 유지하는 트리 중 하나, 다진 탐색 트리의 한 종류
- 다진 탐색 트리 : 한 노드가 여러 자식 노드를 가질 수 있는 트리
- M차 B 트리
    - 한 노드가 가질 수 있는 최대 자식 노드의 개수가 M개인 B 트리
    - 최소 자식 노드의 개수 : $\lceil M/2 \rceil$
- 각 노드에 하나 이상의 키 값 존재, 각 키들이 오름차순으로 저장
- 각 키 사이에 자식 노드의 위치 저장, 키가 자식 노드가 가질 수 있는 값의 범위를 나타냄
- 키가 N개인 노드가 가질 수 있는 자식 노드의 수 → N + 1개
- 각 자식 노드의 값이 왼쪽 자식 노드부터 오른쪽 자식 노드까지 정렬되어 있음
- 모든 리프 노드의 깊이 동일
- B+ 트리
    - 실질적인 데이터가 모두 최하위 리프 노드에 위치, 연결 리스트 형태
    - 리프 노드가 아닌 노드 : 자식 노드의 범위를 분할할 용도로 사용되는 키, 자식 노드의 주소만 저장

### 기타 트리

- 트라이 : 문자열을 효율적으로 탐색하고 저장하기 위한 트리
- 시그먼트 트리, 펜윅 트리 : 빠른 구간 연산을 위한 트리
